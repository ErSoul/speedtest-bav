#!/usr/bin/env python3

__author__ = "David Colmenares"
__copyright__ = "Copyright (C) 2023 David Colmenares"
__license__ = "4-Clause BSD"

import csv
import argparse
import collections
import matplotlib.pyplot as plt
from datetime import datetime


def menu():
    parser = argparse.ArgumentParser(description='Average speedtest bandwidth values by datetime.')
    parser.add_argument('file', help='Source CSV file generated by speedtest.')
    parser.add_argument('-o', '--output', help='Generated formatted file')
    parser.add_argument('-d', '--draw', action='store_true', help='Display chart')

    args = parser.parse_args()
    # args.output = args.output or '/tmp/' + os.path.basename(args.file) # Default path for output file
    return args


def avgInMB(dictionary):
    for key, array in dictionary.items():
        acum = 0
        for downloadValue in array:
            try:
                acum += float(downloadValue)
            except:
                print('Error on:', key,  dictionary[key])
        try:
            dictionary[key] = acum / len(array)
            dictionary[key] /= 8  # Convert to bytes
            dictionary[key] /= 1024  # Convert to KiloBytes
            dictionary[key] /= 1024  # Convert to MegaBytes
            dictionary[key] = round(dictionary[key], 2)  # Round to two decimals
        except Exception as ex:
            print(ex)
            print(key)
            print(array)


def draw(dayTime, download, upload):
    fig, ax = plt.subplots()
    # plt.figure(figsize = (30,10)) # Optimal size to avoid problem of overlapping ticks.

    plt.plot(dayTime, download, color='blue', label="Download (MB)")
    plt.plot(dayTime, upload, color='orange', label="Upload (MB)")

    # Hide ticks labels to avoid overlapping between them.
    every_nth = 2
    for n, label in enumerate(ax.xaxis.get_ticklabels()):
        if n % every_nth != 0:
            label.set_visible(False)

    plt.show()
    # plt.savefig('image.png')


if __name__ == "__main__":
    args = menu()

    dData = dict()  # Download data
    uData = dict()  # Upload data

    with open(args.file, 'r', newline='') as inf:
        reader = csv.reader(inf)
        header = next(reader)
        for row in reader:
            timestamp = datetime.strptime(row[3], '%Y-%m-%dT%H:%M:%S.%fZ')
            row[3] = timestamp.strftime('%H:%M')

            if dData.get(row[3]) is None:
                dData[row[3]] = []
            else:
                dData[row[3]].append(row[6])

            if uData.get(row[3]) is None:
                uData[row[3]] = []
            else:
                uData[row[3]].append(row[7])

    avgInMB(dData)
    avgInMB(uData)

    odData = collections.OrderedDict(sorted(dData.items()))
    ouData = collections.OrderedDict(sorted(uData.items()))

    if args.output is not None:
        with open(args.output, 'w', newline='') as of:
            writer = csv.writer(of)
            writer.writerow(['Daytime', 'Download (MB)', 'Upload (MB)'])
            for k in odData:
                writer.writerow([k, odData[k], ouData[k]])

    if args.draw:
        draw(odData.keys(), odData.values(), ouData.values())
